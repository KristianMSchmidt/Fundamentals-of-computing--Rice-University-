"""In Project 3, you implemented two methods for clustering sets of data. In this Application, we will analyze the performance of these
two methods on various subsets of our county-level cancer risk data set. In particular, we will compare these two clustering methods in
three areas:

Efficiency - Which method computes clusterings more efficiently?
Automation - Which method requires less human supervision to generate reasonable clusterings?
Quality - Which method generates clusterings with less error?
"""

import random
import time
import matplotlib.pyplot as plt
import alg_cluster as c
import alg_project3_solution as p
import alg_project3_viz as viz
######################################################################################
#                                      EFFICIENCY

def gen_random_clusters(num_clusters):
    """
    Creates a list of clusters where each cluster in this list corresponds to one randomly generated point in the square with corners
    (0,0), (0,1), (1,1), (1,0
    """
    cluster_list = []

    for index in range(num_clusters):
        x_coord = random.random()
        y_coord = random.random()
        cluster = c.Cluster(["{}".format(index)], x_coord, y_coord, 0, 0)
        cluster_list.append(cluster)
    return cluster_list

#print gen_random_clusters(10)


def plot_running_times():
    """
    Use gen_random_clusters and your favorite Python timing code to compute the running times of the
    functions slow_closest_pair and fast_closest_pair for lists of clusters of size 2 to 200.
    """

    x_vals = []
    y_1_vals = []
    y_2_vals = []

    for num_clusters in range(2, 200, 1):
        cluster_list = gen_random_clusters(num_clusters)
        x_vals.append(num_clusters)

        # measure process time (= CPU time consumed) of "slow_closest_pair"
        t0 = time.clock()
        p.slow_closest_pair(cluster_list)
        y_1_vals.append(time.clock() - t0)

        # measure process time (= CPU time consumed) of "fast_closest_pair"
        t0 = time.clock()
        p.fast_closest_pair(cluster_list)
        y_2_vals.append(time.clock() - t0)

    plt.plot(x_vals, y_1_vals, label = "slow_closest_pair")
    plt.plot(x_vals, y_2_vals, label = "fast_closest_pair")

    plt.xlabel("Input size (number of clusters)")
    plt.ylabel('CPU running time (sec.)')

    #tegner
    plt.legend()

    plt.title("Comparison of running times (desktop Python)")

    #goer det hele synligt
    plt.show()

#plot_running_times()



################################  AUTOMATION  AND QUALITY#######################################################

#Use alg_project3_viz to create an image of the 9 clusters generated by applying hierarchical clustering to the 111 county cancer risk data
# set. You may submit an image with the 111 counties colored by clusters or an enhanced visualization with the original counties colored by
# cluster and linked to the center of their corresponding clusters by lines.
#Once you are satisfied with your image, upload your image in the peer assessment. Your submitted image will be assessed based on whether it
#matches our solution image. You do not need to include axes, axes labels, or a title for this image.

#


def compute_distortion(cluster_list, data_table):
    """
    Write a function compute_distortion(cluster_list) that takes a list of clusters and uses cluster_error to compute its distortion.
    Now, use compute_distortion to compute the distortions of the two clusterings in questions 5 and 6.
    Enter the values for the distortions (with at least four significant digits) for these two clusterings in the box below.
    Clearly indicate the clusterings to which each value corresponds.
    """
    distortion_of_clustering = 0
    for cluster in cluster_list:
        distortion_of_clustering += cluster.cluster_error(data_table)
    return distortion_of_clustering


def compute_and_plot_distortions():
    """
    Compute the distortion of the list of clusters produced by hierarchical clustering and k-means clustering (using 5 iterations)
    on the 111, 290, and 896 county data sets, respectively, where the number of output clusters ranges from 6 to 20 (inclusive).
    Important note:To compute the distortion for all 15 output clusterings produced by hierarchical_clustering, you should remember
    that you can use the hierarchical cluster of size 20 to compute the hierarchical clustering of size 19 and so on. Otherwise,
     you will introduce an unnecessary factor of 15 into the computation of the 15 hierarchical clusterings.
    """

    #choose data set:
    #data_table = viz.load_data_table(viz.DATA_111_URL)
    #data_table = viz.load_data_table(viz.DATA_290_URL)
    data_table = viz.load_data_table(viz.DATA_896_URL)

    num_output_clusters = []
    kmeans_distortion = []
    hierarchical_distortion = []

    print "\nComputing kmeans distortions"
    for indx in range(6,21):
        ##Dette loop kunne optimeres, saa beregningerne genbruges, men det er ikke noedvendigt, da k_means er saa hurtig
        num_output_clusters.append(indx)

        singleton_list = []
        for line in data_table:
             singleton_list.append(c.Cluster(set([line[0]]), line[1], line[2], line[3], line[4]))

        kmeans_cluster_list = p.kmeans_clustering(singleton_list, indx, 5)
        distortion = compute_distortion(kmeans_cluster_list, data_table)
        kmeans_distortion.append(distortion)
        print indx, distortion

    print "Computed kmeans distortions"
    print ""
    print "Computing hierarchical distortions"


    for line in data_table:
          singleton_list.append(c.Cluster(set([line[0]]), line[1], line[2], line[3], line[4]))

    hierarchical_cluster_list = singleton_list

    for indx in range(20, 5, -1):
        hierarchical_cluster_list = p.hierarchical_clustering(hierarchical_cluster_list, indx)
        distortion = compute_distortion(hierarchical_cluster_list, data_table)
        hierarchical_distortion.append(distortion)
        print indx, distortion

    hierarchical_distortion.reverse()

    print "Computed hierarchical distortions\n"
    print "Plotting data"

    plt.plot(num_output_clusters, kmeans_distortion, label = "K-means clustering")
    plt.plot(num_output_clusters, hierarchical_distortion, label = "Hierarchical clustering")

    plt.xlabel("Number of output clusters")
    plt.ylabel('Distortion')

    #tegner
    plt.legend()

    plt.title("Comparison of distortion of two clustering methods \n Dataset: 896 counties")

    #goer det hele synligt
    plt.show()

    #print num_output_clusters
    #print distortion


print compute_and_plot_distortions()
